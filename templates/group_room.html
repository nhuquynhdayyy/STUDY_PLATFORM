<!-- templates/group_room.html -->
{% extends 'base.html' %}
{% block content %}
<div class="bg-slate-900 min-h-screen text-white p-8">
    <div class="flex justify-between items-center mb-6">
        <h2 class="text-2xl font-bold">{{ room.name }} <span class="text-sm font-mono text-gray-500">#{{ room.room_code }}</span></h2>
        <a href="{% url 'dashboard' %}" class="bg-red-600 px-6 py-2 rounded-xl font-bold">Leave Room</a>
    </div>

    <!-- Video Grid -->
    <div id="video-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- Video của chính mình -->
        <div class="relative bg-black rounded-3xl overflow-hidden aspect-video border-2 border-blue-500">
            <video id="localVideo" autoplay muted playsinline class="w-full h-full object-cover"></video>
            <div class="absolute bottom-4 left-4 bg-black/50 px-3 py-1 rounded-lg text-xs">You (Host)</div>
        </div>
    </div>
</div>

<script>
const roomCode = "{{ room.room_code }}";
const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
const socket = new WebSocket(`${wsScheme}://${window.location.host}/ws/study/${roomCode}/`);

const videoGrid = document.getElementById('video-grid');
const localVideo = document.getElementById('localVideo');
let localStream;
const peers = {}; // Lưu trữ RTCPeerConnection của các thành viên khác

// 1. Lấy Camera/Mic
navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then(stream => {
    localStream = stream;
    localVideo.srcObject = stream;
});

socket.onmessage = async (event) => {
    const data = JSON.parse(event.data);

    // Có người mới vào -> Gửi Offer cho họ
    if (data.type === "new_peer") {
        initPeerConnection(data.channel_name, data.username, true);
    } 
    
    // Xử lý Signaling
    const { payload, sender_channel, sender_name } = data;
    if (!payload) return;

    if (payload.type === "offer") {
        const pc = initPeerConnection(sender_channel, sender_name, false);
        await pc.setRemoteDescription(new RTCSessionDescription(payload.offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.send(json({ type: "answer", answer: answer, target: sender_channel }));

    } else if (payload.type === "answer") {
        await peers[sender_channel].setRemoteDescription(new RTCSessionDescription(payload.answer));

    } else if (payload.type === "ice") {
        await peers[sender_channel].addIceCandidate(new RTCIceCandidate(payload.candidate));
    }
};

function initPeerConnection(targetChannel, username, isOffer) {
    const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
    peers[targetChannel] = pc;

    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

    pc.onicecandidate = e => {
        if (e.candidate) socket.send(json({ type: "ice", candidate: e.candidate, target: targetChannel }));
    };

    pc.ontrack = e => {
        if (document.getElementById(`video-${targetChannel}`)) return;
        const container = document.createElement('div');
        container.id = `video-${targetChannel}`;
        container.className = "relative bg-black rounded-3xl overflow-hidden aspect-video border border-slate-700";
        const video = document.createElement('video');
        video.srcObject = e.streams[0];
        video.autoplay = true;
        video.className = "w-full h-full object-cover";
        container.appendChild(video);
        videoGrid.appendChild(container);
    };

    if (isOffer) {
        pc.createOffer().then(offer => {
            pc.setLocalDescription(offer);
            socket.send(json({ type: "offer", offer: offer, target: targetChannel }));
        });
    }
    return pc;
}

function json(obj) { return JSON.stringify(obj); }
</script>
{% endblock %}